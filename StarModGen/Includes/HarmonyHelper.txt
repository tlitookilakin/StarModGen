using HarmonyLib;
using StardewModdingAPI;
using System.Reflection;

namespace StarModGen.Utils;

///<summary>A utility to more conveniently register harmony patches.</summary>
///<param name="harmony">The harmony instance to use</param>
///<param name="monitor">Your mod's Monitor, for logging patch errors.</param>
public class HarmonyHelper(Harmony harmony, IMonitor monitor)
{
	private static readonly string[] patchTypeNames = ["prefix", "postfix", "transpiler", "finalizer"];
	private const BindingFlags AnyDeclared = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic;

	private MethodInfo[] targets = [];
	private Type? targetType;

	///<summary>The instance of harmony being used by the helper.</summary>
	public Harmony Harmony => harmony;
	
	///<summary>Begins patching a method of the given name on the given type.</summary>
	public HarmonyHelper With(Type t, string name)
		=> WithImpl(name, false, t)l

	///<summary>Begins patching a method of the given name on the given type.</summary>
	public HarmonyHelper With<T>(string name)
		=> WithImpl(name, false, typeof(T));

	///<summary>Beings patching a method of the given name on the current type.</summary>
	public HarmonyHelper With(string name)
		=> WithImpl(name, false);

	///<summary>Begins patching a property of the given name on the given type.</summary>
	public HarmonyHelper WithProperty<T>(string name, bool getter)
		=> WithPropertyImpl(name, false, getter, typeof(T));
		
	///<summary>Beings patching a property of the given name on the current type.</summary>
	public HarmonyHelper WithProperty(string name, bool getter)
		=> WithPropertyImpl(name, false, getter);
		
	///<summary>Begins patching all methods with the given name on the given type.</summary>
	public HarmonyHelper WithAll<T>(string name, Func<MethodInfo, bool>? predicate = null)
		=> WithImpl(name, true, typeof(T), predicate);
		
	///<summary>Begins patching all methods with the given name on the current type.</summary>
	public HarmonyHelper WithAll(string name, Func<MethodInfo, bool>? predicate = null)
		=> WithImpl(name, true, null, predicate);

	///<summary>Apply a method as a prefix.</summary>
	public HarmonyHelper Prefix(Delegate use)
		=> PatchImpl(new(use.Method), 0);

	///<summary>Apply a method as a postfix.</summary>
	public HarmonyHelper Postfix(Delegate use)
		=> PatchImpl(new(use.Method), 1);

	///<summary>Apply a method as a transpiler</summary>
	public HarmonyHelper Transpiler(Delegate use)
		=> PatchImpl(new(use.Method), 2);

	///<summary>Apply a method as a finalizer</summary>
	public HarmonyHelper Finalizer(Delegate use)
		=> PatchImpl(new(use.Method), 3);

	private HarmonyHelper WithImpl(string name, bool all, Type? target = null, Func<MethodInfo, bool>? predicate = null)
	{
		if (target is not null)
			targetType = target;

		if (targetType is null)
			throw new InvalidOperationException("Must specify target type.");

		if (all)
		{
			targets = targetType
				.GetMethods(AnyDeclared | BindingFlags.Static | BindingFlags.Instance)
				.Where(m => m.Name == name && (predicate is null || predicate(m)))
				.ToArray();
		}
		else
		{
			var m = targetType.GetMethod(name, AnyDeclared | BindingFlags.Static | BindingFlags.Instance);
			targets = m is null ? [] : [m];
		}

		if (targets.Length is 0)
			monitor.Log($"No method with name '{name}' is declared by type '{target}'.", LogLevel.Error);

		return this;
	}

	private HarmonyHelper WithPropertyImpl(string name, bool getter, bool all, Type? target = null)
	{
		if (target is not null)
			targetType = target;

		if (targetType is null)
			throw new InvalidOperationException("Must specify target type.");

		PropertyInfo[] targs;

		if (all)
		{
			targs = targetType
				.GetProperties(AnyDeclared | BindingFlags.Static | BindingFlags.Instance)
				.Where(m => m.Name == name && ((!getter && m.CanWrite) || (getter && m.CanRead)))
				.ToArray();
		}
		else
		{
			var m = targetType.GetProperty(name, AnyDeclared | BindingFlags.Static | BindingFlags.Instance);
			targs = m is null ? [] : [m];
		}

		MethodInfo[] targets = new MethodInfo[targs.Length];
		for (int i = 0; i < targs.Length; i++)
			targets[i] = getter ? targs[i].GetMethod! : targs[i].SetMethod!;

		if (targets.Length is 0)
			monitor.Log($"No property with name '{name}' is declared by type '{target}'.", LogLevel.Error);

		return this;
	}

	private HarmonyHelper PatchImpl(HarmonyMethod use, int type)
	{
		HarmonyMethod?[] applies = new HarmonyMethod?[4];
		applies[type] = use;

		if (targetType is null)
			throw new InvalidOperationException("Target type must be specified before patching.");

		for (int i = 0; i < targets.Length; i++)
		{
			try
			{
				harmony.Patch(targets[i], applies[0], applies[1], applies[2], applies[3]);
			}
			catch (Exception e)
			{
				monitor.Log($"Failed to apply {patchTypeNames[type]} '{use.method}' to '{targets[i]}':\n{e}", LogLevel.Error);
			}
		}

		return this;
	}
}
